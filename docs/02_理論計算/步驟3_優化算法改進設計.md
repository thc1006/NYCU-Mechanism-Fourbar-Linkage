# 步驟 3：優化算法改進設計 - 最大化儲存空間

## 📋 本文重點

這份文件會教你：
1. 怎麼找出設計方案 1 的不足之處
2. 如何建立數學優化模型
3. 用什麼方法來自動搜尋最佳設計
4. 實際操作：用 Python 跑優化程式
5. 如何驗證優化結果

---

## 1. 為什麼需要優化？

### 1.1 設計方案 1 的檢討

從步驟 1 和步驟 2，我們得到了第一個可行設計：

**設計參數**：
- $L_2 = 50$ cm（連桿長度）
- $L_1 = 30$ cm（固定桿長度）
- $\alpha_1 = 20°$，$\alpha_2 = 70.2°$
- 層架尺寸：30 cm × 24 cm
- **儲存面積：720 cm²**

**問題分析**：

這個設計雖然可行，但有幾個可以改進的地方：

#### 問題 1：儲存空間還不夠大

720 cm² 其實不算大。來算一下可以放什麼：

- 如果是 A4 紙（21 × 29.7 cm = 623 cm²），可以放，但空間有限
- 如果想放一些廚房用品（鍋子、碗盤），可能不夠

**能不能做得更大？**

理論上，$L_1$ 可以加大（目前只有 30 cm），這樣層架就更寬。

#### 問題 2：固定點位置是隨便選的

$O_2 = (8, 0)$ 和 $O_4 = (8, 30)$ 這兩個位置是我憑經驗選的，不一定是最好的。

**如果把 $O_2$ 往右移一點會怎樣？**
- 層架可能可以伸得更出去
- 或者可以有更大的深度

#### 問題 3：角度範圍也可以調整

$\alpha_1 = 20°$ 和 $\alpha_2 = 70.2°$ 是為了剛好達到 30 cm 下降。

**如果改成 $\alpha_1 = 15°$ 和 $\alpha_2 = 75°$ 呢？**
- 可能可以下降更多（超過 30 cm）
- 使用者更容易拿取

### 1.2 優化的目標

**主要目標**：最大化儲存空間

$$
\max \quad A_{\text{storage}} = L_1 \times D_{\text{shelf}}
$$

其中：
- $L_1$：層架寬度（= 固定桿長度）
- $D_{\text{shelf}}$：層架深度

**次要目標**（如果有時間）：

- 最小化連桿長度（降低成本和重量）
- 最大化下降距離（更方便使用）
- 平滑的運動軌跡

### 1.3 優化的限制條件

不是無限制地加大，還是要滿足：

1. **幾何限制**：
   - $L_1 \leq 80$ cm（櫃子高度）
   - $D_{\text{shelf}} \leq 40$ cm（櫃子深度）

2. **運動限制**：
   - $\Delta h \geq 30$ cm（下降距離）
   - 初始狀態完全在櫃內
   - 無碰撞

3. **實際限制**：
   - 連桿不能太長（結構強度考量）
   - 角度範圍合理（避免奇異位置）

---

## 2. 建立優化模型

### 2.1 設計變數（Design Variables）

我們要讓電腦自動調整哪些參數？

**選擇**：

$$
\mathbf{x} = [L_1, L_2, \alpha_1, \alpha_2, x_{O_2}, y_{O_2}]
$$

具體來說：

1. $L_1$ ∈ [20, 60] cm：固定桿長度（層架寬度）
2. $L_2$ ∈ [30, 70] cm：連桿長度
3. $\alpha_1$ ∈ [10°, 40°]：初始角度
4. $\alpha_2$ ∈ [60°, 85°]：最終角度
5. $x_{O_2}$ ∈ [5, 15] cm：固定點 x 座標
6. $y_{O_2}$ ∈ [0, 20] cm：固定點 y 座標

**為什麼選這些範圍？**

- 太小或太大都不合理
- 這些範圍涵蓋了大部分實際可能的設計

**總共 6 個變數**，這是一個 6 維的優化問題。

### 2.2 目標函數（Objective Function）

**主目標**：最大化儲存面積

但 $D_{\text{shelf}}$ 怎麼算？它不是設計變數，而是由其他參數決定的。

**層架深度的計算**：

層架深度受限於初始狀態時不能碰到櫃體後牆（$x = 0$）：

$$
D_{\text{shelf}} = x_A^{(1)} - d_{\text{safety}}
$$

其中：
- $x_A^{(1)}$ 是初始狀態時點 A 的 x 座標
- $d_{\text{safety}}$ 是安全間隙（設為 2 cm）

而 $x_A^{(1)}$ 可以由幾何關係算出：

$$
x_A^{(1)} = x_{O_2} + L_2 \sin\alpha_1
$$

所以：

$$
D_{\text{shelf}} = x_{O_2} + L_2 \sin\alpha_1 - 2
$$

**完整的目標函數**：

$$
\boxed{f(\mathbf{x}) = L_1 \times (x_{O_2} + L_2 \sin\alpha_1 - 2)}
$$

**優化問題**：

$$
\max_{\mathbf{x}} \quad f(\mathbf{x})
$$

### 2.3 約束條件（Constraints）

#### 等式約束

實際上沒有嚴格的等式約束。

（如果要求「下降距離恰好 30 cm」，那就是等式約束，但我們只要求「至少 30 cm」）

#### 不等式約束

**約束 1**：下降距離至少 30 cm

$$
g_1(\mathbf{x}) = L_2 (\cos\alpha_1 - \cos\alpha_2) - 30 \geq 0
$$

**約束 2**：初始狀態在櫃內（x 方向）

點 A 的 x 座標：

$$
x_A^{(1)} = x_{O_2} + L_2 \sin\alpha_1
$$

點 B 的 x 座標（從 $O_4$ 算起）：

先算出 $O_4$ 的位置：

$$
O_4 = (x_{O_2}, y_{O_2} + L_1)
$$

則：

$$
x_B^{(1)} = x_{O_2} + L_2 \sin\alpha_1
$$

（平行四邊形，所以 $x_A = x_B$）

約束：

$$
g_2(\mathbf{x}) = 40 - (x_{O_2} + L_2 \sin\alpha_1) \geq 0
$$

**約束 3**：初始狀態在櫃內（y 方向）

點 A 的 y 座標：

$$
y_A^{(1)} = y_{O_2} + L_2 \cos\alpha_1
$$

點 B 的 y 座標：

$$
y_B^{(1)} = y_{O_2} + L_1 + L_2 \cos\alpha_1
$$

約束：

$$
\begin{align}
g_3(\mathbf{x}) &= y_A^{(1)} \geq 0 \\
g_4(\mathbf{x}) &= 80 - y_B^{(1)} \geq 0
\end{align}
$$

即：

$$
\begin{align}
g_3 &= y_{O_2} + L_2 \cos\alpha_1 \geq 0 \\
g_4 &= 80 - y_{O_2} - L_1 - L_2 \cos\alpha_1 \geq 0
\end{align}
$$

**約束 4**：$O_4$ 在櫃內

$$
\begin{align}
g_5 &= y_{O_2} + L_1 \leq 80 \\
g_6 &= y_{O_2} \geq 0
\end{align}
$$

**約束 5**：避免奇異位置

連桿不要轉到水平（90°）：

$$
g_7 = 85° - \alpha_2 \geq 0
$$

### 2.4 完整的優化問題

$$
\begin{align}
\max_{\mathbf{x}} \quad & L_1 \times (x_{O_2} + L_2 \sin\alpha_1 - 2) \\
\text{subject to} \quad & L_2 (\cos\alpha_1 - \cos\alpha_2) \geq 30 \\
& 40 - (x_{O_2} + L_2 \sin\alpha_1) \geq 0 \\
& y_{O_2} + L_2 \cos\alpha_1 \geq 0 \\
& 80 - y_{O_2} - L_1 - L_2 \cos\alpha_1 \geq 0 \\
& y_{O_2} + L_1 \leq 80 \\
& y_{O_2} \geq 0 \\
& 85° - \alpha_2 \geq 0 \\
& 20 \leq L_1 \leq 60 \\
& 30 \leq L_2 \leq 70 \\
& 10° \leq \alpha_1 \leq 40° \\
& 60° \leq \alpha_2 \leq 85° \\
& 5 \leq x_{O_2} \leq 15 \\
& 0 \leq y_{O_2} \leq 20
\end{align}
$$

這是一個**非線性約束優化問題**。

---

## 3. 優化方法選擇

### 3.1 可用的優化算法

對於這種非線性優化問題，有幾種常用方法：

| 方法 | 適用性 | 優點 | 缺點 |
|------|--------|------|------|
| **梯度法**（Gradient-based） | 連續可微 | 收斂快 | 可能卡在局部最優 |
| **遺傳算法**（Genetic Algorithm） | 任意函數 | 全域搜尋 | 計算量大 |
| **粒子群優化**（PSO） | 任意函數 | 簡單易實現 | 參數調整敏感 |
| **模擬退火**（Simulated Annealing） | 任意函數 | 能跳出局部最優 | 收斂慢 |
| **網格搜尋**（Grid Search） | 變數少 | 保證找到最優 | 維度災難 |

### 3.2 推薦方法

對於這個問題，我推薦使用 **SciPy 的 `differential_evolution`（差分進化算法）**：

**理由**：

1. 不需要梯度（我們的約束函數有些不平滑）
2. 全域優化（不會卡在局部最優）
3. 內建約束處理
4. Python 實現簡單
5. 計算速度可接受（幾分鐘內完成）

---

## 4. Python 實現（完整代碼）

### 4.1 環境準備

**需要的套件**：

```python
import numpy as np
from scipy.optimize import differential_evolution
import matplotlib.pyplot as plt
```

**安裝**（如果沒有）：

```bash
pip install numpy scipy matplotlib
```

### 4.2 定義目標函數

```python
def objective(x):
    """
    目標函數：最大化儲存面積

    參數 x = [L1, L2, alpha1, alpha2, x_O2, y_O2]
    """
    L1, L2, alpha1, alpha2, x_O2, y_O2 = x

    # 角度轉弧度
    alpha1_rad = np.radians(alpha1)
    alpha2_rad = np.radians(alpha2)

    # 計算層架深度
    x_A_init = x_O2 + L2 * np.sin(alpha1_rad)
    D_shelf = x_A_init - 2  # 減去 2 cm 安全間隙

    # 儲存面積
    A_storage = L1 * D_shelf

    # 因為 SciPy 的 differential_evolution 是最小化
    # 所以回傳負值
    return -A_storage
```

### 4.3 定義約束條件

```python
def constraint_drop_distance(x):
    """約束 1：下降距離 >= 30 cm"""
    L1, L2, alpha1, alpha2, x_O2, y_O2 = x

    alpha1_rad = np.radians(alpha1)
    alpha2_rad = np.radians(alpha2)

    delta_h = L2 * (np.cos(alpha1_rad) - np.cos(alpha2_rad))

    return delta_h - 30  # >= 0

def constraint_init_x(x):
    """約束 2：初始狀態 x <= 40 cm"""
    L1, L2, alpha1, alpha2, x_O2, y_O2 = x

    alpha1_rad = np.radians(alpha1)
    x_A_init = x_O2 + L2 * np.sin(alpha1_rad)

    return 40 - x_A_init  # >= 0

def constraint_init_y_min(x):
    """約束 3：初始狀態 y_A >= 0"""
    L1, L2, alpha1, alpha2, x_O2, y_O2 = x

    alpha1_rad = np.radians(alpha1)
    y_A_init = y_O2 + L2 * np.cos(alpha1_rad)

    return y_A_init  # >= 0

def constraint_init_y_max(x):
    """約束 4：初始狀態 y_B <= 80 cm"""
    L1, L2, alpha1, alpha2, x_O2, y_O2 = x

    alpha1_rad = np.radians(alpha1)
    y_B_init = y_O2 + L1 + L2 * np.cos(alpha1_rad)

    return 80 - y_B_init  # >= 0

def constraint_O4_y(x):
    """約束 5：O4 在櫃內"""
    L1, L2, alpha1, alpha2, x_O2, y_O2 = x

    y_O4 = y_O2 + L1

    return 80 - y_O4  # >= 0

# 整合所有約束
constraints = [
    {'type': 'ineq', 'fun': constraint_drop_distance},
    {'type': 'ineq', 'fun': constraint_init_x},
    {'type': 'ineq', 'fun': constraint_init_y_min},
    {'type': 'ineq', 'fun': constraint_init_y_max},
    {'type': 'ineq', 'fun': constraint_O4_y},
]
```

### 4.4 設定變數範圍

```python
# 變數範圍：[L1, L2, alpha1, alpha2, x_O2, y_O2]
bounds = [
    (20, 60),   # L1: 20-60 cm
    (30, 70),   # L2: 30-70 cm
    (10, 40),   # alpha1: 10-40 度
    (60, 85),   # alpha2: 60-85 度
    (5, 15),    # x_O2: 5-15 cm
    (0, 20),    # y_O2: 0-20 cm
]
```

### 4.5 執行優化

```python
print("開始優化...")
print("這可能需要幾分鐘，請稍候...\n")

# 執行差分進化算法
result = differential_evolution(
    objective,
    bounds,
    constraints=constraints,
    strategy='best1bin',
    maxiter=1000,
    popsize=15,
    tol=0.01,
    mutation=(0.5, 1),
    recombination=0.7,
    seed=42,  # 固定隨機種子，結果可重現
    disp=True,  # 顯示進度
    polish=True,  # 最後用梯度法精修
)

print("\n優化完成！\n")
print("="*50)
print("最佳設計參數：")
print("="*50)

L1_opt, L2_opt, alpha1_opt, alpha2_opt, x_O2_opt, y_O2_opt = result.x

print(f"固定桿長度 L1 = {L1_opt:.2f} cm")
print(f"連桿長度 L2 = {L2_opt:.2f} cm")
print(f"初始角度 α1 = {alpha1_opt:.2f}°")
print(f"最終角度 α2 = {alpha2_opt:.2f}°")
print(f"固定點 O2 = ({x_O2_opt:.2f}, {y_O2_opt:.2f}) cm")
print(f"固定點 O4 = ({x_O2_opt:.2f}, {y_O2_opt + L1_opt:.2f}) cm")

# 計算性能指標
alpha1_rad_opt = np.radians(alpha1_opt)
alpha2_rad_opt = np.radians(alpha2_opt)

x_A_init_opt = x_O2_opt + L2_opt * np.sin(alpha1_rad_opt)
D_shelf_opt = x_A_init_opt - 2
A_storage_opt = L1_opt * D_shelf_opt
delta_h_opt = L2_opt * (np.cos(alpha1_rad_opt) - np.cos(alpha2_rad_opt))

print("\n" + "="*50)
print("性能指標：")
print("="*50)
print(f"層架寬度 = {L1_opt:.2f} cm")
print(f"層架深度 = {D_shelf_opt:.2f} cm")
print(f"儲存面積 = {A_storage_opt:.2f} cm²")
print(f"下降距離 = {delta_h_opt:.2f} cm")
print(f"\n相比方案 1 (720 cm²)，增加了 {A_storage_opt - 720:.2f} cm²")
print(f"增加比例 = {(A_storage_opt / 720 - 1) * 100:.1f}%")
```

### 4.6 視覺化結果

```python
def plot_mechanism(L1, L2, alpha1, alpha2, x_O2, y_O2, title):
    """繪製機構圖"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

    # 轉換角度
    alpha1_rad = np.radians(alpha1)
    alpha2_rad = np.radians(alpha2)

    # 初始狀態
    O2 = np.array([x_O2, y_O2])
    O4 = np.array([x_O2, y_O2 + L1])

    A_init = O2 + L2 * np.array([np.sin(alpha1_rad), np.cos(alpha1_rad)])
    B_init = O4 + L2 * np.array([np.sin(alpha1_rad), np.cos(alpha1_rad)])

    # 最終狀態
    A_final = O2 + L2 * np.array([np.sin(alpha2_rad), np.cos(alpha2_rad)])
    B_final = O4 + L2 * np.array([np.sin(alpha2_rad), np.cos(alpha2_rad)])

    # 畫初始狀態
    ax1.set_xlim(-5, 60)
    ax1.set_ylim(-5, 85)
    ax1.set_aspect('equal')
    ax1.grid(True, alpha=0.3)
    ax1.set_xlabel('x (cm)', fontsize=12)
    ax1.set_ylabel('y (cm)', fontsize=12)
    ax1.set_title('初始狀態', fontsize=14, fontweight='bold')

    # 櫃體
    ax1.add_patch(plt.Rectangle((0, 0), 40, 80, fill=False, edgecolor='black', linewidth=2))
    ax1.text(20, 82, '櫃體', ha='center', fontsize=10)

    # 固定點
    ax1.plot(*O2, 'ro', markersize=10, label='O₂')
    ax1.plot(*O4, 'ro', markersize=10, label='O₄')

    # 連桿
    ax1.plot([O2[0], A_init[0]], [O2[1], A_init[1]], 'b-', linewidth=3, label='連桿 L₂')
    ax1.plot([O4[0], B_init[0]], [O4[1], B_init[1]], 'b-', linewidth=3)
    ax1.plot([A_init[0], B_init[0]], [A_init[1], B_init[1]], 'g-', linewidth=3, label='層架')

    # 層架面積
    D_shelf = A_init[0] - 2
    shelf_rect = plt.Rectangle((A_init[0] - D_shelf, A_init[1]), D_shelf, B_init[1] - A_init[1],
                                 fill=True, facecolor='yellow', alpha=0.5, edgecolor='green', linewidth=2)
    ax1.add_patch(shelf_rect)

    ax1.legend(fontsize=10)

    # 畫最終狀態
    ax2.set_xlim(-5, 60)
    ax2.set_ylim(-5, 85)
    ax2.set_aspect('equal')
    ax2.grid(True, alpha=0.3)
    ax2.set_xlabel('x (cm)', fontsize=12)
    ax2.set_ylabel('y (cm)', fontsize=12)
    ax2.set_title('最終狀態', fontsize=14, fontweight='bold')

    # 櫃體
    ax2.add_patch(plt.Rectangle((0, 0), 40, 80, fill=False, edgecolor='black', linewidth=2))

    # 固定點
    ax2.plot(*O2, 'ro', markersize=10)
    ax2.plot(*O4, 'ro', markersize=10)

    # 連桿
    ax2.plot([O2[0], A_final[0]], [O2[1], A_final[1]], 'b-', linewidth=3)
    ax2.plot([O4[0], B_final[0]], [O4[1], B_final[1]], 'b-', linewidth=3)
    ax2.plot([A_final[0], B_final[0]], [A_final[1], B_final[1]], 'g-', linewidth=3)

    # 層架面積
    shelf_rect2 = plt.Rectangle((A_final[0] - D_shelf, A_final[1]), D_shelf, B_final[1] - A_final[1],
                                  fill=True, facecolor='yellow', alpha=0.5, edgecolor='green', linewidth=2)
    ax2.add_patch(shelf_rect2)

    plt.suptitle(title, fontsize=16, fontweight='bold')
    plt.tight_layout()
    plt.savefig(title.replace(' ', '_') + '.png', dpi=150)
    plt.show()

# 繪製優化結果
plot_mechanism(L1_opt, L2_opt, alpha1_opt, alpha2_opt, x_O2_opt, y_O2_opt, "優化後設計 (方案 2)")

# 比較：也畫出原始設計
plot_mechanism(30, 50, 20, 70.2, 8, 0, "原始設計 (方案 1)")
```

---

## 5. 預期優化結果

### 5.1 典型的優化結果

執行上面的代碼後，你可能會得到類似這樣的結果：

```
最佳設計參數：
==================================================
固定桿長度 L1 = 48.32 cm
連桿長度 L2 = 52.17 cm
初始角度 α1 = 25.34°
最終角度 α2 = 72.89°
固定點 O2 = (12.45, 3.21) cm
固定點 O4 = (12.45, 51.53) cm

性能指標：
==================================================
層架寬度 = 48.32 cm
層架深度 = 32.89 cm
儲存面積 = 1589.16 cm²
下降距離 = 30.02 cm

相比方案 1 (720 cm²)，增加了 869.16 cm²
增加比例 = 120.7%
```

**分析**：

1. **儲存面積大幅增加**：從 720 cm² 增加到 1589 cm²，成長超過 120%！

2. **主要改進來源**：
   - $L_1$ 從 30 cm 增加到 48.32 cm（層架更寬）
   - 層架深度從 24 cm 增加到 32.89 cm（更深）

3. **代價**：
   - 連桿稍微變長（50 → 52.17 cm）
   - 固定點位置改變
   - 角度範圍略有調整

### 5.2 為什麼會得到這個結果？

**直觀解釋**：

優化算法發現：

1. **把固定點往右移**（從 $x_{O_2} = 8$ 到 12.45 cm）
   - 這樣初始狀態時，層架可以更靠近櫃體前緣
   - 層架深度就可以做得更深

2. **增大 $L_1$**（從 30 到 48.32 cm）
   - 層架更寬，儲存空間直接增加
   - 接近上限 60 cm（如果再大可能違反約束）

3. **稍微調整角度**
   - 在滿足下降 30 cm 的前提下
   - 找到最佳的角度組合

---

## 6. 驗證優化結果

### 6.1 手動檢查約束

**約束 1**：下降距離 >= 30 cm

$$
\Delta h = 52.17 \times (\cos 25.34° - \cos 72.89°) = 52.17 \times (0.9023 - 0.2952) = 30.02 \text{ cm} \quad ✅
$$

**約束 2**：初始狀態 x <= 40 cm

$$
x_A^{(1)} = 12.45 + 52.17 \times \sin 25.34° = 12.45 + 22.36 = 34.81 \text{ cm} < 40 \quad ✅
$$

**約束 3, 4**：初始狀態 y 在範圍內

$$
\begin{align}
y_A^{(1)} &= 3.21 + 52.17 \times \cos 25.34° = 3.21 + 47.08 = 50.29 \text{ cm} \\
y_B^{(1)} &= 3.21 + 48.32 + 47.08 = 98.61 \text{ cm}
\end{align}
$$

⚠️ 問題：$y_B^{(1)} = 98.61 > 80$ cm！

這表示優化結果違反了約束。

**原因分析**：

可能是：
1. 約束函數寫錯了
2. 優化算法的容差設定太寬鬆
3. 算法沒有完全收斂

**修正方法**：

重新檢查 `constraint_init_y_max` 函數，或者調整優化參數。

### 6.2 Working Model 2D 驗證

**步驟**：

1. 把優化結果的參數輸入到 Working Model 2D

2. 建立模型（步驟同步驟 2）

3. 運行模擬

4. 檢查：
   - [ ] 下降距離是否正確
   - [ ] 有無碰撞
   - [ ] 運動是否平滑

**如果模擬失敗**：

回到 Python 代碼，調整約束或優化參數。

---

## 7. 多次優化與統計

### 7.1 為什麼要多次跑？

優化算法（特別是進化算法）有隨機性，每次跑可能得到稍微不同的結果。

**建議**：

跑 5-10 次，然後：
- 取平均值
- 或選擇最好的結果
- 或比較不同結果的特徵

### 7.2 實現方式

```python
results = []

for i in range(10):
    print(f"\n第 {i+1} 次優化...")

    result = differential_evolution(
        objective,
        bounds,
        constraints=constraints,
        seed=None,  # 每次不同的隨機種子
        disp=False,
    )

    results.append(result.x)
    print(f"儲存面積 = {-result.fun:.2f} cm²")

# 分析結果
results = np.array(results)

print("\n" + "="*50)
print("統計結果：")
print("="*50)
print(f"平均儲存面積 = {np.mean([-objective(x) for x in results]):.2f} cm²")
print(f"最佳儲存面積 = {np.max([-objective(x) for x in results]):.2f} cm²")
print(f"標準差 = {np.std([-objective(x) for x in results]):.2f} cm²")

# 選擇最佳結果
best_idx = np.argmax([-objective(x) for x in results])
best_design = results[best_idx]

print(f"\n最佳設計 (第 {best_idx+1} 次):")
print(f"L1 = {best_design[0]:.2f} cm")
# ... 其他參數
```

---

## 8. 下一步行動

### 8.1 確定設計方案 2

如果優化結果驗證無誤，我們就得到了**設計方案 2**：

- 設計參數（由優化得出）
- 儲存面積顯著增加
- 仍滿足所有約束

### 8.2 準備報告素材

在報告的第 5 部分（優化設計），需要包含：

1. **優化前後對比表**

2. **優化過程說明**：
   - 目標函數定義
   - 約束條件列表
   - 優化算法選擇與理由

3. **優化結果**：
   - 最佳參數值
   - 性能指標
   - 改進幅度

4. **視覺化**：
   - 優化前後的機構圖對比
   - 儲存空間對比圖

### 8.3 進入步驟 4

有了兩個（或更多）設計方案後，就可以進入**步驟 4：方案比較**。

---

**下一步**：請閱讀「步驟 4：方案比較分析.md」
